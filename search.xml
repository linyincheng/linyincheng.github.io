<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo和github搭建个人博客]]></title>
    <url>%2F2017%2F11%2F10%2Fforth%2F</url>
    <content type="text"><![CDATA[准备工作github的注册gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。所以要使用github，就请先到github官网进行注测。具体注册过程和关于git的学习，建议到廖雪峰的官方网站,这个网站上面有很详细的git教程，希望仔细阅读。 node.js下载由于hexo是基于Node.js的静态博客框架，所以我们先下载node.js,移步Node.js官网下载稳定版即可，下载完成后打开安装(按照默认路径安装即可)。然后打开cmd命令行或者git Bash 输入： node -v 如果出现版本号就说明已经安装成功了。关于github和hexo的内容就到这里。下面就开始我们的主题（hexo和github搭建个人博客）吧。 搭建过程安装hexoNode和Git都安装好后,用户存放hexo的配置文件,然后安装Hexo。打开 node.js输入： sudo npm install -g hexo 或者(nmp i -g hexo) 安装完成后，到github登录你前面注册的账号，然后点击New repository新建一个项目，项目名为：yourname.github.io,注意：一个账号只能建立一个名为yourname.github.io，如果已经有了，就随便建一个 如：blog将项目克隆到本地仓库，打开git Bash上(注意：你想把这个 项目放到哪个磁盘就在哪个磁盘打开git Bash，但是最好不要放在C盘). git clone 你项目上的SSh 克隆完成后，打开文件夹，打开git Bash或者cmd(注意是当前路径就行)输入： hexo init 安装hexo所需要的依赖。好啦，到此为止呢，所有的安装工作都完成了！接下来就是生成博客页面了。 生成静态页面hexo generate (hexo g) 这时你的博客页面已经生成，然后再输入： hexo sever (hexo s) 启动本地服务,进行博客页面的预览,完成这一步后,进入localhost:4000查看hexo页面是否出现,一般来说使用了yourname.github.io创建的项目名都可以看到页面,而其他的看不到页面的,因为你们的环境还没配置好(不要着急，接着往下看！) 全局配置首先，你要找到项目根目录下的_config.yml文件]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,Number和Boolean等基本类型的包装对象]]></title>
    <url>%2F2017%2F11%2F08%2Fthree%2F</url>
    <content type="text"><![CDATA[JavaScript的数据类型被分为两大类：引用类型和基本类型。 基本类型：Undefined,Null,Boolean,Number,String 引用类型：Object,Array,Date,RegExp等,你想的没错，引用类型就是对象。 我们都知道引用类型(即对象)都有属性和方法的，而基本类型是木有的，对吧。但是你一定见到过和下面相似的代码： var s=&quot;text&quot;; var s2=s.charAt(1); alert(s);//e 例子中的s是String类型，也就是基本类型，但是s却可以调用出charAt()方法来，这是为什么呢？ 主要是因为在基本类型中，有三个比较特殊的存在就是：String Number Boolean，这三个基本类型都有自己对应的包装对象。并且随时等候召唤。包装对象呢，其实就是对象，有相应的属性和方法。下面来个栗子： var s=&quot;text&quot;; var s2=s.charAt(1);//解析器在解析到这句代码的时候就会在后台执行下面的代码 (//()里面的程序是在后台执行的; var s=new String(&quot;text&quot;);//后台用new来创建了一个基本类型相同的对象 var s2=s.charAt(1);//然后通过新创建的对象来调用charAt()方法，并且返回给s2 s=null//调用完成之后就把这个对象给销毁了 )//实际上这个操作是在一瞬间就完成的，实际上我们没有改变字符串本身的值 alert(s);//e 由此我们可以知道，引用类型和基本包装对象的区别在于：生存期 引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了一瞬间。 所以我们无法直接给基本类型添加方法： var s=&quot;text&quot;;//创建一个字符串 s.length=4;//给它设置一个 属性值 (//()里面的程序是在后台执行的; var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象 var s.length=4;//通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存 因为这个对象马上要被销毁了 s=null;//对象s又被销毁了； ) var l=s.length;//查询这个属性 alert(l);//undefined alert(s.length)//undefined ( var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象 var s.length=undefined;//因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果 s=null;//对象s又被销毁了； ) 当我们要给基本类型加上属性和方法时，我们要在基本包装对象的原型上添加的： //给字符串添加方法 要写到对应的包装对象的原型下才行 var s=&quot;text&quot;; String.prototype.last= fuction(){ return this.charAt(this.length); }; s.last(); ( var str = new String(&apos;hello&apos;);// 找到基本包装对象，new一个和字符串值相同的对象， str.last(); // 通过这个对象找到了包装对象下的方法并调用 str =null; // 这个对象被销毁 )]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中数据类型以及变量作用域]]></title>
    <url>%2F2017%2F11%2F04%2Fsecond%2F</url>
    <content type="text"><![CDATA[数据类型（变量类型）javascript中的数据类型有：字符串(String)、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空(Null)、未定义(undefined)。 var x ; //x是undefined类型 var x=123; //x是数字类型 var x=&quot;123&quot;; //x是字符串类型 var x=true/false; //x是布尔类型 var x=[]; //x是数组类型 var x={1,2,3} //x是一个对象类型 但是Null这种数据类型该怎么表示呢？其实Null类型只有一个值：null，但是当我们这样写的时候：var x=null; console.log(typeof(x)); 返回的结果却是object,也就是说x是一个对象类型。（在逻辑上，你可以认为null是一个空的对象指针，所以结果为“object”）。那么，我们该如何判断一个类型呢，很简单，我们只要把变量的值与null进行比较即可： &lt;script&gt; var x=null; if(x===null){ alert(&quot;is null&quot;); } alert(null==undefined);//结果为true alert(null===undefined); //结果却为false &lt;/script&gt; 两个等号的时候undefined实际上是从值null派生来的，所以显示true。但是用到严格等于的时候，null和undefined的数据类型是不一样的，所以返回了false。 变量变量的声明在js中，变量声明分为两种，显示声明和隐式声明 var x=100;//显示声明 x=100;//隐式声明 全局变量和局部变量在函数function中使用var声明（即显示声明）的变量是局部变量，而没有var声明（即隐式声明）的变量是全局变量。当我们使用未经任何声明的变量时js就会报错，但是我使用未经声明的而被赋值的变量时js就不会报错了。相反js会认为我们隐式声明了一个全局变量，所以这一点一定要注意。 变量作用域任何程序语言中变量的作用域都是一个很关键的细节。JS中变量的作用域相对与JAVA、C这类语言显得更自由，一个很大的特征就是JS变量没有块级作用域，函数中的变量在整个函数都中有效，看看下面的代码： &lt;script type=&quot;text/javascript&quot;&gt; function outPut(s){ document.writeln(s);//定义一个输出函数 } var i=0;//全局变量 outPut(i);//调用输出函数结果为0 function text(){ var i=1; outPut(i); //1,因为text函数里面定义了一个局部变量，所以在text函数调用outPut的时候是输出text函数里面的局部变量i的值，也就是1 } text(); outPut(i)//仍然是0，因为这时候调用输出函数是在text函数之外调用的，所以里面的局部变量没有起作用； function aa(){ i=2;//这里使用了前面讲的隐式声明，也就是说这里定义了一个全局变量i，而这个i会把前面定义的 同名的全局变量i给覆盖掉 outPut(i);//2 } aa(); outPut(i)//2 i=2; function bb(){ var i; outPut(i);//undefined i=1; outPut(i);//1 }// 这个函数中i已经被var声明了，只是前面未被赋值而已，后面的i虽然是隐式声明的模样，但是别忘了它前面已经被var声明了， bb(); outPut(i);//2 所以bb()中的i并未被覆盖。 &lt;/script&gt; 从上面就可以证明JS如果用var在函数体中声明变量，那么此变量在且只在该函数体内有效，函数运行结束时，本地变量即可销毁了。 基本类型和引用类型 JS不同于JAVA、C这些语言，在变量申明时并不需要声明变量的存储空间。变量中所存储的数据可以分为两类：基本类型和引用类型。其中数值、布尔值、null和undefined属于基本类型，对象、数组和函数属于引用类型。 基本类型在内存中具有固定的内存大小。例如：数值型在内存中占有八个字节，布尔值只占有一个字节。对于引用型数据，他们可以具有任意长度，因此他们的内存大小是不定的，因此变量中存储的实际上是对此数据的引用，通常是内存地址或者指针，通过它们我们可以找到这个数据。 引用类型和基本类型在使用行为上也有不同之处： &lt;script type=&quot;text/javascript&quot;&gt; //定义一个输出函数 function outPut(s){ document.writeln(s) } var a = 3; var b = a; outPut(b); //3 a = 4; outPut(a); //4 outPut(b); //3 &lt;/script&gt; 对基本类型b进行赋值时，实际上是又开辟了一块内存空间，因此改变变量a的值对变量b没有任何影响。 &lt;script type=&quot;text/javascript&quot;&gt; //定义一个输出函数 function outPut(s){ document.writeln(s) } var a_array = [1,2,3]; var b_array = a_array; outPut(b_array); //1,2,3 a_array[3] = 4; outPut(b_array);//1,2,3,4 &lt;/script&gt; 上面是对引用类型的变量赋值，实际上他们传递的是对内存地址的引用，因此对a_array和b_array的存取，实际上都是操作的同一块内存区域。如果希望重新分配内存空间存储引用型变量，那么我就需要使用克隆方法或者自定义方法来复制引用变量的数据。 关于变量作用域我知道的就这些了，这之中有什么写的不对或不够的地方，可以指正出来，也可以和我讨论，分享个人的观点，共同进步。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中事件的冒泡和事件的捕获]]></title>
    <url>%2F2017%2F10%2F31%2Ffirst%2F</url>
    <content type="text"><![CDATA[首先，我们知道微软提出的是事件冒泡，网景提出的是事件捕获。这两个概念的提出是为了解决页面中事件流(即事件发生顺序)的问题。 &lt;div id=&quot;outer&quot;&gt; &lt;p id=&quot;inner&quot;&gt;点击我！&lt;/p&gt; &lt;/div&gt; 上面的代码中一个div元素当中有一个p子元素，如果两个元素都有一onclick事件处理函数，那么我们怎么才能知道哪一个函数会先被触发呢？ 微软和网景这两个公司提出两种相反的概念解决了这个问题。 事件冒泡事件冒泡可以形象地比喻为一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会最内层的元素开始触发，一直往上传播，直到document对象为止。 所以上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document。 事件捕获事件捕获是和事件冒泡完全相反的概念，也就是说，事件会从最外的document对象开始触发，然后不断往里触发。直到最里面的元素被触发为止。 上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p。 在处理事件冒泡中，IE，DOM2级以及DOM0级分别给出以下的处理方法： var EventUtil={ //通过addEventListener 添加监听事件 addHandler:function(element,type,handler){ //element:元素，type:事件类型“click”,handler:处理函数 if(element.addEventListener){ //Dom2级的处理事件 element.addEventListener(type,handler,false); }else if(element.attachEvent){ // IE处理事件 element.attachEvent(&apos;on&apos;+type,handler); }else{ //Dom0级的处理时事件 element[&apos;on&apos;+type]=handler; } }, //通过removeHandler //删除事件 removeHandler:function(element,type,handler){ if(element.removeHandler){//Dom2级的处理事件 element.removeEventListener(type,handler,false); }else if(element.detachEvent){ // IE处理事件 element.detachEvent(&apos;on&apos;+type,handler); }else{//DOM0级处理事件 element[&apos;on&apos;+type]=null; } }, } addEventListener的第三个参数“DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。 addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数： element.addEventListener(event, function, useCapture)第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 阻止事件的冒泡行为以及阻止冒泡函数( stopPropagation())有时候我们开发网页的时候不希望页面出现事件冒泡，我们可以使用阻止事件冒泡处理函数。这个函数使用如下: stopPropagation:function(evnt){ if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble=ture; } 其中的event.cancelBubble=true是指取消事件冒泡，将事件停止下来，不让事件往上面的元素传递。 冒泡还是 捕获？对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。 IE浏览器兼容IE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数object.setCapture();object.attachEvent(event, function)两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
