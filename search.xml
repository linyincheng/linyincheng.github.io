<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Js中事件的冒泡和事件的捕获]]></title>
    <url>%2F2017%2F10%2F31%2Ffirst%2F</url>
    <content type="text"><![CDATA[首先，我们知道微软提出的是事件冒泡，网景提出的是事件捕获。这两个概念的提出是为了解决页面中事件流(即事件发生顺序)的问题。 &lt;div id=&quot;outer&quot;&gt; &lt;p id=&quot;inner&quot;&gt;点击我！&lt;/p&gt; &lt;/div&gt; 上面的代码中一个div元素当中有一个p子元素，如果两个元素都有一onclick事件处理函数，那么我们怎么才能知道哪一个函数会先被触发呢？ 微软和网景这两个公司提出两种相反的概念解决了这个问题。 事件冒泡事件冒泡可以形象地比喻为一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会最内层的元素开始触发，一直往上传播，直到document对象为止。 所以上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document。 事件捕获事件捕获是和事件冒泡完全相反的概念，也就是说，事件会从最外的document对象开始触发，然后不断往里触发。直到最里面的元素被触发为止。 上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p。 在处理事件冒泡中，IE，DOM2级以及DOM0级分别给出以下的处理方法： var EventUtil={ //通过addEventListener 添加监听事件 addHandler:function(element,type,handler){ //element:元素，type:事件类型“click”,handler:处理函数 if(element.addEventListener){ //Dom2级的处理事件 element.addEventListener(type,handler,false); }else if(element.attachEvent){ // IE处理事件 element.attachEvent(&apos;on&apos;+type,handler); }else{ //Dom0级的处理时事件 element[&apos;on&apos;+type]=handler; } }, //通过removeHandler //删除事件 removeHandler:function(element,type,handler){ if(element.removeHandler){//Dom2级的处理事件 element.removeEventListener(type,handler,false); }else if(element.detachEvent){ // IE处理事件 element.detachEvent(&apos;on&apos;+type,handler); }else{//DOM0级处理事件 element[&apos;on&apos;+type]=null; } }, } addEventListener的第三个参数“DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。 addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数： element.addEventListener(event, function, useCapture)第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 阻止事件的冒泡行为以及阻止冒泡函数( stopPropagation())有时候我们开发网页的时候不希望页面出现事件冒泡，我们可以使用阻止事件冒泡处理函数。这个函数使用如下: stopPropagation:function(evnt){ if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble=ture; } 其中的event.cancelBubble=true是指取消事件冒泡，将事件停止下来，不让事件往上面的元素传递。 冒泡还是 捕获？对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。 IE浏览器兼容IE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数object.setCapture();object.attachEvent(event, function)两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
