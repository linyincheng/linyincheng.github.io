<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6的学习总结]]></title>
    <url>%2F2018%2F05%2F18%2FES6%2F</url>
    <content type="text"></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生Js的图片预加载和懒加载技术]]></title>
    <url>%2F2018%2F04%2F17%2Flazyload%2F</url>
    <content type="text"><![CDATA[各种宽高页可见区域宽： document.body.clientWidth;||document.documentElement.clientWidth 网页可见区域高： document.body.clientHeight;document.documentElement.clientHeight 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 网页正文部分上： window.screenTop; 网页正文部分左： window.screenLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; 懒加载技术为什么要用到懒加载在实际的项目开发中，我们通常会遇见这样的场景：一个页面有很多图片，而首屏出现的图片大概就一两张，那么我们还要一次性把所有图片都加载出来吗？显然这是愚蠢的，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，技术上现实其中要用的技术就是图片懒加载–到可视区域再加载。 怎样实现懒加载呢？思路：将页面里所有img属性src属性用data-xx代替，监听滚动，直接用window.onscroll(),当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。img标签代码实现：如下所示 加载代码实现： window.onscroll =_.throttle(this.watchscroll, 200); watchscroll () { var bodyScrollHeight = document.body.scrollTop;// body滚动高度 var windowHeight = window.innerHeight;// 视窗高度 var imgs = document.getElementsByClassName(&apos;lazyloadimg&apos;); for (var i =0; i &lt; imgs.length; i++) { var imgHeight = imgs[i].offsetTop;// 图片距离顶部高度 if (imgHeight &lt; windowHeight + bodyScrollHeight) { imgs[i].src = imgs[i].getAttribute(&apos;data-src&apos;); //src属性由data-src属性替代了 img[i].className = img[i].className.replace(&apos;lazyloadimg&apos;,&apos;&apos;); } } }]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习随笔]]></title>
    <url>%2F2018%2F04%2F14%2Fliver%2F</url>
    <content type="text"><![CDATA[我发现我最近都喜欢上写博客，总是想着把生活中的一些琐事以及学习中遇到的问题写在博客上。因为我感觉可以通过写博客来表达自己对生活和学习的感受，可以更清楚的了解自己。 2018/4/17今天学习了Js动画库的封装，看了老师讲的视频，感觉挺简单的，但是到自己动手去实践的时候，发现有很多基础的知识还没掌握，这反映了自己在之前的学习的状态，Js动画的原理其实也不是很难，很多都是日常生活中或者我们在一些大型的网站见过的一些动画效果，比如说最基础的轮播图，缓动动画，滚动条的滚动原理，返回顶部等等这些动画效果。其实，这两天自己的学习状态一直不是很好，常常会多想（@ @），整个人感觉很浮躁，不能安下心来学习。学习的时候老是在那多想，就是不肯动手去敲代码，学编程一定要多练。从明天开始，每天至少都要敲200行代码或者用学到的知识做一个案例出来。严格要求自己。加油！ 2018/5/4 这几天都在学ES6语法，感觉信息量有点大，看得不是很懂，可能跟ES5的基础不牢固有关吧，特别是字符串扩展和正则表达式的扩展。这两个内容的有些概念不太能够理解，对Unicode字符集不是很了解，特意去百度了，但是没找到想要的答案，看了知乎上的一些网友的解释，感觉还是懵懵懂懂的样子。 2018/5/16谈谈进入大学以来的情况 2015年9月13日，我拉着一大包行李，做了一天一夜的火车。来到了地处河南省北部的八朝古都–安阳。当我看到安阳工学院的大门时，我就在想我以后要在这里生活四年，当时就许下愿望，要在大学里面怎么样怎么样做，要做什么事。比如要在大学里找到一个女朋友之类的(跪了 求别说 给跪了 现在都大三毕业了还是一枚单身狗)(T_T)； 曾梦想仗剑走天涯 大学里是没有什么志同道合的朋友的，因为大学里每个人都有自己的梦想，有的人在大学里想进入学生会，学习如何与人交际，有的人从进入大学开始就下定决心要考研，所以这群考研的人每天都认真地去上课，而有的人则是想在大学里学一两门谋生的技术，毕业后找一份不错的工作。(我可能就是这一类人吧。大二开始加入学院里面的信息技术实验室，学习前端开发，到现在学习前端都快两年了吧)。大学里面，孤独是常有的事，吃饭是自己一个人，有时实在不知道吃啥（这里吐槽一下，我是一个南方人，对北方人的饮食习惯不太能适应，三年了，都是这样）。 转眼过去多年时间多少离合悲欢曾经志在四方少年羡慕南飞的燕各自奔前程的身影匆匆渐行渐远未来在哪里平凡啊谁给我答案]]></content>
      <categories>
        <category>学习与生活</category>
      </categories>
      <tags>
        <tag>生活，学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于函数闭包的理解]]></title>
    <url>%2F2018%2F04%2F14%2Fbibao%2F</url>
    <content type="text"><![CDATA[学习前端的过程中，特别是在Javascript学习的过程中，每个学习者都会遇到一个很难理解的难点，那就是闭包。下来我来讲讲我对闭包的了解： 函数作用域首先，讲闭包，就一定要讲到JS的作用域（函数作用域）了，函数作用域有一些特点; 特点一（函数能访问到函数外部的变量）var num =10; function fn1(){ console.log(num); } fn1(); //10 特点二（函数内部线的变量不能被函数外部访问）function fn2(){ var num =10; } console.log(num);//结果为undefined; 如何在函数外部访问函数内部的变量呢，正常情况下，是访问不到的。因此我们要通过一种变通的方法，就是在函数内部定义一个函数，这个函数就可以访问外层函数的变量。 来个最简单的闭包看看function fn1(){ var a=1 ; function fn2(){ var b=11; console.log(a) } fn2(); console.log(b); } fn1();//结果只打印了a的值，也就是执行了fn2();而没有打印b的值,而是出现了一个b is undefined的错误； （&quot;Uncaught ReferenceError: b is not defined&quot;） 简单来说闭包就是在嵌套函数中有访问外层函数成员变量权限的函数]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS原型，原型链和继承的理解]]></title>
    <url>%2F2018%2F04%2F06%2Fproperty%2F</url>
    <content type="text"><![CDATA[在学习JavaScript的过程中，经常会遇到几个难点，比如原型，原型链以及闭包之类的，下面我们就来聊聊我所理解的这些难点内容。 普通对象和函数对象JavaScript是一门面向对象的语言，既然面向对象，那就得有对象才行对吧，所谓万物皆对象，但是对象之间也是有区别的，对象分为函数对象和普通对象。函数对象可以创建普通对象，但是普通对象不能创建函数对象，普通对象在js的语法中什么特权也没有。举例说明一下函数对象和普通对象： var o1 = {}; var o2 =new Object(); var o3 = new f1(); function f1(){}; ==(等价于) var f1 = new Function(); var f2 = function(){}; var f3 = new Function(&apos;str&apos;,&apos;console.log(str)&apos;); console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 以上例子中，o1,o2,o3都是普通对象，f1,f2,f3都是函数对象凡是通过new Function创建的对象都是函数对象，其他都是普通对象（通常通过Object创建），可以通过typeof来判断。 构造函数function Person(name,age,sex){ this.name = name; this.age = age; this.sex = sex; this.sayName =function(){ alert(this.name)}; } var person1 = new Person(&quot;lyc&quot;,21,&quot;男&quot;); var person2 = new Person(&quot;lyl&quot;,20,&quot;女&quot;); person1,person2都是Person的实例，它们都有一个constructor（指针）属性指向Person。 console.log(person1.constructor == Person);//true console.log(person2.constructor == Person);//true person1和person2是构造函数Person的实例化。实例的属性constructor永远指向它的构造函数。 原型对象（终于进入主题了(-_-)）Javascript中，我们每定义一个对象（函数也是对象）时，JavaScript都会在对象中预定义一些属性。其中每个函数对象都有一个prototype属性,这个属性指向的是函数对象的原型对象。举个栗子： function Person(){} //创建一个函数对象 //利用函数对象的prototype属性在原型上设置属性 Person.prototype.name = &quot;Nicholas&quot;; Person.prototype.age = 23; Person.prototype.job = &quot;Worker&quot;; Person.prototype.sayName = function(){ alert(this.name); } //创建实例化对象 var person1 = new Person(); var person2 = new Person(); console.log(person1.name);//Nicholas console.log(person2.name);//Nicholas console.log(person1.age);//23 console.log(person2.age);//23 每个对象都有一个proto属性，但只有函数对象才有prototype属性。所谓原型对象： Person.prototype = { name:&quot;Nicholas&quot;, age: 23, job:&quot;Worker&quot;, sayName:function(){alert(this.name)} }; 上面我设置了四个属性，其实它还有一个默认属性constructor属性，这个属性不指向Person这个函数对象了。原型对象Person.prototype就是Person的实例。 person1.__proto__ === Person.prototype; Person.__proto__ === Function.prototype;//构造函数 Person.prototype.__proto__ === Object.prototype; Object.__proto__ === Function.prototype;//构造函数 Object.prototype.__proto__ === null; 由上面的等式我们知道 person1–&gt;Person.prototype–&gt;Object.prototype–&gt;null,构成了这样的一条原型链，null是原型链的最顶端。就比如说，你是你妈妈生的，而你妈妈是你姥姥生的，一直追溯到类人猿是从null中进化而来的。 属性的继承原型属性的出现就是为了继承的，就像上面的栗子中，person1和person2的属性都是从它们共同的原型上继承而来的。当然person1和person2也可以有自己的属性。就好比，你可以继承家里的财产，同时你也可以有自己的的财产。在JavaScript中有三继承方式分别是原型继承（也叫拷贝继承），构造函数实现继承和call，apply实现继承。 原型继承原型继承其实就是借助已有的对象去创建子对象，把子对象的原型属性prototype指向父对象。 function Parents(name,age){ this.name = name; this.age = age; this.sayHi = function(){ alert(&quot;my name is &quot;+this.name+&quot;my age is &quot;+this.age); }; } function Child(grade){ this.grade = grade ; this.sayGrade = function(){ alert(&quot;my grade is&quot;+this.grade); }; } Child.prototype = new Parents(&quot;林云&quot;,&quot;22&quot;); var chi= new Child(69); chi.sayHi(); chi.sayGrade(); 构造函数实现继承function Parents(name,age){ this.name = name; this.age = age; this.sayHi = function(){ alert(&quot;my name is &quot;+this.name+&quot;my age is &quot;+this.age); }; } function Child(name,age,grade){ this.grade = grade ; this.sayHi= Parents;//这里构造了sayHi函数 this.sayHi(name,age); this.sayGrade = function(){ alert(&quot;my grade is&quot;+this.grade); }; } var chi= new Child(&quot;林云&quot;,22,69); chi.sayHi(); chi.sayGrade(); call,apply实现继承function Parents(name,age){ this.name = name; this.age = age; this.sayHi = function(){ alert(&quot;my name is &quot;+this.name+&quot;my age is &quot;+this.age); }; } function Child(name,age,grade){ this.grade = grade ; //Person.call(this,name,age); //Person.apply(this,[name,age]); Person.apply(this,arguments); this.sayGrade = function(){ alert(&quot;my grade is&quot;+this.grade); }; } var chi= new Child(&quot;林云&quot;,22,69); chi.sayHi(); chi.sayGrade();]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的基本应用]]></title>
    <url>%2F2017%2F12%2F28%2Fajax%2F</url>
    <content type="text"><![CDATA[AjaxAjax是前后台实现数据交互的一门技术，可以在无需加载整个网页的情况下能够更新部分网页的技术，也就是说在后台与服务器之间进行少量的数据交互可以使网页不用更新整体，只是更新更改的那一部分。Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。 Ajax的使用使用Ajax需要下载安装它的运行环境xampp https://www.apachefriends.org/zh_cn/index.html由于是国外的网站，可能会比较慢。进去之后选择与你电脑相匹配的系统版本下载安装，一直点击下一步即可。安装完成后，找到根目录下有一个xampp.contrl.exe 的应用程序，打开这个程序，开启Apache服务器就可以使用了。第一步创建XmlHttpRequest()对象,调用这个对象的open方法，open()接收三个参数，第一个参数是请求方式, 第二个是请求文本的 URL,第三个是是否异步，true表示异步，false表示同步 。 发送请求。 注册事件onreadystatechange事件,onload事件 Ajax请求纯文本或Ajax请求PHP文件首先在xampp/htdocs的路径下新建一个文件夹（名字任你），进去新建一个.txt的文件，里面随便写点吧js代码如下： &lt;script&gt; document.getElementsById(&quot;btn&quot;).addEventlistener(&apos;click&apos;,loadTxt); function loadTxt(){ var XHR = new XmlHttpRequest();//创建一个对象 XHR.open(&apos;GET&apos;,&apos;slow.txt&apos;,true);//如果请求的是PHP文件，把slow.txt改成对应的PHP文件 XHR.onload = funciton(){ document.write(this.response); }; XHR.send(); } //这里做一下兼容,因为IE浏览器支持的是ActiveXobject()的方法 //这里封装一个createXHR()函数; /** /*param createXHR() /* 封装一个兼容ie5，6，7的XmlHttpRequeat的使用函数 /*/ function createXHR(){ if(typeof XMLHttpRequest != &quot;undefined&quot;){//ie7+，Firefox chrome return new XMLHttpRequest; }else if(typeof ActiveXObject !=&quot;undefined&quot;){//ie6以下 if(typeof arguments.callee.activeXString !=&quot;string&quot;){ var versions = [&quot;MSXML2.XMLHttp.6.0&quot;,&quot;MSXML2.XMLHttp.3.0&quot;,&quot;MSXML2.XMLHttp&quot;],i,len; for(i=0,len=versions.length;i&lt;len;i++){ try{ new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; }catch(ex){ //跳过 } } } return new ActiveXObject(arguments.callee.activeXString); }else{ throw newError(&quot;No XHR object available.&quot;); } } Ajax请求Json对象function loadUser(){ var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;user.json&quot;,true);//用Get请求 xhr.onload = function(){ if (this.status == 200) { // console.log(this.responseText); var user = JSON.parse(this.responseText); // console.log(user.name); var output = &apos;&apos;; output += &apos;&lt;ul&gt;&apos;+ &apos;&lt;li&gt;&apos;+user.id+&apos;&lt;/li&gt;&apos;+ &apos;&lt;li&gt;&apos;+user.name+&apos;&lt;/li&gt;&apos;+ &apos;&lt;li&gt;&apos;+user.email+&apos;&lt;/li&gt;&apos;+ &apos;&lt;/ul&gt;&apos;; ; document.getElementById(&apos;user&apos;).innerHTML = output; } } xhr.send(); } Ajax请求网络接口(以github接口为例)function loadUsers(){ var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;,&quot;https://api.github.com/users&quot;,true);//这里的URL改成网络地址 xhr.onload = function(){ var users = JSON.parse(this.responseText); // console.log(users); var output = &apos;&apos;; for(var i in users){ output += ` &lt;div class=&quot;user&quot;&gt; &lt;img src=&quot;${users[i].avatar_url}&quot; width=&quot;70&quot; height=&quot;70&quot; /&gt; &lt;ul&gt; &lt;li&gt;ID: ${users[i].id}&lt;/li&gt; &lt;li&gt;Login: ${users[i].login}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `; } document.getElementById(&apos;users&apos;).innerHTML = output; } xhr.send(); } Ajax的两种请求方式（get请求和post请求）get是最常见的请求，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器，对XHR而言，位于传入open( )方法的URL末尾的查询字符串必须经过正确的编码才行，即查询字符串的每个参数的名称和值都 必须使用encodeURIComponent（）进行编码，然后才能放到URL的末尾，而且所有的名-值对都必须由&amp;号分隔； xhr.open(&quot;GET&quot;,&quot;example.php?name1=value1&amp;name2=value2&quot;,true); POST请求应该把数据作为请求的主体提交，其请求的主体可以包含非常多的数据，而且格式不限。POST请求必须设置Content-Type值为application/x-form-www-urlencoded；如果不设置Content-Type 头部信息，那么发送给服务器的的数据就不会出现在$_POST超全局变量中。发送请求时POST请求在使用send方法时,需赋予其参数； xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(params); get请求和post请求两者的区别（1）使用Get请求时,参数在URL中显示,而使用Post请求,则不会显示出来；（2）Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度的限制,只能传递大约1024字节.（3）Get请求请求需注意缓存问题,Post请求不需担心这个问题；（4）Post请求必须设置Content-Type值为application/x-form-www-urlencoded；（5）发送请求时,因为Get请求的参数都在url里,所以send函数发送的参数为null,而Post请求在使用send方法时,却需赋予其参数；（6）GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 post请求： function postMethod(){ var xhr = new createXHR(); var userName = document.getElementById(“userName”).value; var age = document.getElementById(“age”).value; var data = “userName=” + encodeURTComponent( userName ) + “&amp;age=” + encodeURTComponent( age ); //不用担心缓存问题 xhr.open( “post”, “example.php”, true ); //必须设置,否则服务器端收不到参数 xhr.setRequestHeader( “Content-Type”, “application/x-www-form-urlencoded” ); xhr.onreadystatechange = function(){ if( xhr.readyState = 4 &amp;&amp; xhr.status == 200 ){ document.getElementById(“result”).innerHTML = xhr.responseText; } } //发送请求,要data数据 xhr.send( data ); } get请求： function getMethod(){ var xhr = new createXHR(); var userName = document.getElementById(“userName”).value; var age = document.getElementById(“age”).value; //添加参数,以求每次访问不同的url,以避免缓存问题 xhr.open( “get”, “example.php?userName=” + encodeURTComponent( userName ) + “&amp;age=” + encodeURTComponent( age ) + “&amp;random=” + Math.random(), true ); xhr.onreadystatechange = function(){ if( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ){ document.getElementById(“result”).innerHTML = xhr.responseText; } } //发送请求,参数为null xhr.send( null ); } 跨域请求的几种方法什么是跨域？跨域是指从一个域名的网页去请求另一个域名网页的资源，比如从www.baidu.com 页面去请求https://www.tmall.com的资源。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域。]]></content>
      <tags>
        <tag>前端开发</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this的用法]]></title>
    <url>%2F2017%2F11%2F18%2Fthis%2F</url>
    <content type="text"><![CDATA[1. this是啥？简言之，this是JavaScript语言中定义的众多关键字之一，它的特殊在于它自动定义于每一个函数域内，但是this倒地指引啥东西却让很多人张二摸不着头脑。这里我们留个小悬念，希望看完这篇文章了你能回答出来this到底指引个甚。 2. this有什么用呢？既然this这么难以理解，那么为个甚还要用它呢？我们来看个例子： function identify() { return this.name.toUpperCase(); } function sayHello() { var greeting = &quot;Hello, I&apos;m &quot; + identify.call( this ); console.log( greeting ); } var person1= { name: &quot;Kyle&quot; }; var person2= { name: &quot;Reader&quot; }; identify.call( person1); // KYLE identify.call( person2); // READER sayHello.call( person1); // Hello, I&apos;m KYLE sayHello.call( person2); // Hello, I&apos;m READER 这段代码很简单，我们定义了两个函数，分别为identify和sayHello。并且在不同的对象环境下执行了它们，达到了复用的效果，而不用为了在不同的对象环境下执行而必须针对不同的对象环境写对应的函数了。简言之，this给函数带来了复用。那边客官又问了，我不用this一样可以实现。如： function identify(context) { return context.name.toUpperCase(); } function sayHello(context) { var greeting = &quot;Hello, I&apos;m &quot; + identify( context); console.log( greeting ); } var person1= { name: &quot;Kyle&quot; }; var person2= { name: &quot;Reader&quot; }; identify( person1); // KYLE identify( person2); // READER sayHello( person1); // Hello, I&apos;m KYLE sayHello( person2); // Hello, I&apos;m READER 仔细一看，这位兄弟给出的解决方法的确也达到了类似的效果。赞一个！我想说的是，随着代码的增加，函数嵌套、各级调用等变得越来越复杂，那么传递一个对象的引用将变得越来越不明智，它会把你的代码弄得非常乱，甚至你自己都无法理解清楚。而this机制提供了一个更加优雅而灵便的方案，传递一个隐式的对象引用让代码变得更加简洁和复用。好了，知道了this的用处，那么再看看我们对它的误解。 3. 我们对this的误解我们都学过其他语言，在很多编程语言中都有this机制，我们会惯性地把其他语言里对this的理解带入到JavaScript中来，同时，由于this这个单词的理解导致我们对this产生了误解，我们先澄清一下对它的误解。 3.1.误解一 this引用function本身我们都知道，在函数里引用函数可以达到递归和给函数属性赋值的效果。而这在很多应用场景下显得非常有用。所以，很多人都误以为this就是指引function本身。例如： function fn(num){ console.log(&quot;fn:&quot;+num); this.count++; } fn.count=0; var i; for(i=0;i&lt;10;i++){ if(i&gt;5){ fn(i); } } //fn:6 //fn:7 //fn:8 //fn:9 console.log(fn.count);//0 上面我们想要记录fn被调用的次数，可是明显fn被调用了四次但count仍然为0。咋回事捏？这里简单解释下，fn里第4行的自增隐式的创建了一个全局变量count，由于初始值为undefined，所以每一次自增其实依然不是一个数字，你在全局环境下打印count（window.count）输出的应该是NaN。而第6行定义的函数熟悉变量count依然没变，还是0。如果对这个执行结果不清楚的，欢迎去看我前些天的那篇博文（聊一下JS中的作用域scope和闭包closure scope和closure），在这里你只需要知道，this引用的是function这种理解是错误的就行。这边就会又有人问了，既然this不是引用function，那么我要实现递归函数，该咋引用呢?这里简单回答下介个问题，两种方法：①函数体内用函数名来引用函数本身②函数体内使用arguments.callee来引用函数（不推荐）。那么既然第二种方法不推荐，匿名函数咋引用呢？用第一种，并且给匿名函数一个函数名即可（推荐）。 我们对this的误解二：this引用的是function的词法作用域JS的引擎内对词法作用域的实现的确像是一个对象，拥有属性和函数，但是这仅仅是JS引擎的一种实现，对代码来说是不可见的，也就是说词法作用域“对象”在JS代码中取不到。 funciton fn1(){ var a=2; this.fn2();//以为this引用的是fn1的词法作用域 } function fn2(){ console.log(this.a); } fn1();//ReferenceError; 面的代码明显没有执行出想要的结果，从而可以看到this并没有引用函数的词法作用域。甚至，可以肯定的说，这个例子里fn2可以在fn1里正确执行都是偶然的 this到底跟啥有关系呢？其实this跟函数在哪里定义没有半毛钱关系，函数在哪里调用才决定了this到底引用的是啥。也就是说this跟函数的定义没关系，跟函数的执行有大大的关系。所以，记住，“函数在哪里调用才决定了this到底引用的是啥”。 this机制的四种规则默认绑定全局变量function fn(){ console.log(this.a); } var a= 1111; fn();//这里结果是1111 this绑定的是全局变量a，这种机制是最常见的。 隐式绑定隐式调用的意思是，函数调用时拥有一个上下文对象，就好像这个函数是属于该对象的一样。例如： function fn(){ console.log(this.a); } var obj = { a:2, fn:fn }; obj.fn();//2 --this引用obj。 最后一个调用该函数的对象是传到函数的上下文对象（绕懵了）。如： function fn(){ console.log(this.a); } var obj1 = { a:2, obj2:obj2 }; var obj2 = { a:42, fn:fn }; obj1.obj2.fn()//42 this引用的是obj2; 当this失去隐式绑定时，指向全局变量。如： function fn(){ console.log(this.a); } var obj = { a:2, fn:fn }; var bar = obj.fn;//这里存在隐式绑定但它执行的结果是把fn赋给bar var a=0; bar() //0 显示绑定function fn(){ console.log(this.a); } var obj = { a:2, }; fn.call(obj);//2 call(),bind()和apply()它们接收的第一个参数即是上下文对象并将其赋值给this。 new新对象的绑定如果是一个构造函数，那么用new来调用，那么绑定的将是新创建的对象。如： function Fn(a) { this.a = a; } var bar = new Fn( 2 ); console.log( bar.a );// 2 现实写代码的过程中肯定比这要多和复杂，但是无论多复杂多乱，它们都是混合应用上面的几个规则和情况而已。只要你的思路和理解是清晰的，那肯定没问题的。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo和github搭建个人博客]]></title>
    <url>%2F2017%2F11%2F10%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[准备工作github的注册gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。所以要使用github，就请先到github官网进行注测。具体注册过程和关于git的学习，建议到廖雪峰的官方网站,这个网站上面有很详细的git教程，希望仔细阅读。 node.js下载由于hexo是基于Node.js的静态博客框架，所以我们先下载node.js,移步Node.js官网下载稳定版即可，下载完成后打开安装(按照默认路径安装即可)。然后打开cmd命令行或者git Bash 输入： node -v 如果出现版本号就说明已经安装成功了。关于github和hexo的内容就到这里。下面就开始我们的主题（hexo和github搭建个人博客）吧。 搭建过程安装hexoNode和Git都安装好后,用户存放hexo的配置文件,然后安装Hexo。打开 node.js输入： sudo npm install -g hexo 或者(nmp i -g hexo) 安装完成后，到github登录你前面注册的账号，然后点击New repository新建一个项目，项目名为：yourname.github.io,注意：一个账号只能建立一个名为yourname.github.io，如果已经有了，就随便建一个 如：blog将项目克隆到本地仓库，打开git Bash上(注意：你想把这个 项目放到哪个磁盘就在哪个磁盘打开git Bash，但是最好不要放在C盘). git clone 你项目上的SSh 克隆完成后，打开文件夹，打开git Bash或者cmd(注意是当前路径就行)输入： hexo init 安装hexo所需要的依赖。好啦，到此为止呢，所有的安装工作都完成了！接下来就是生成博客页面了。 生成静态页面hexo generate (hexo g) 这时你的博客页面已经生成，然后再输入： hexo sever (hexo s) 启动本地服务,进行博客页面的预览,完成这一步后,进入localhost:4000查看hexo页面是否出现,一般来说使用了yourname.github.io创建的项目名都可以看到页面,而其他的看不到页面的,因为你们的环境还没配置好(不要着急，接着往下看！) 全局配置首先，你要找到项目根目录下的_config.yml文件,打开文件进行配置。 Site(基本信息部分)# Site title: //博客名 subtitle: //可填可不填 description: //你博客的描述 author: //作者 language: zh-Hans timezone: Asia/Shanghai 特别提醒：冒号后面有个空格，这个空格必不可少！！下面的内容也一样！！！！ URL(博客地址)如果你是使用yourname.github.io为项目名的话，那你就如下配置就行。root后面不能为空 url: https://yourname.github.io/ root: / 要是你是用其他的项目名的话，比如blog,请按照下面配置： url: https://yourname.github.io/blog root: /blog 完成这里之后,看到文件的最后。 Deployment(部署信息)deploy: type: git repository: 你项目的SSH branch: master(如果博客地址是“https://yourname.github.io/blog”,分支名就是gh-pages) 全局配置结束。这时候你需要更新你的本地仓库。在命令行输入： hexo generate(hexo g) hexo sever (hexo s) 点击localhost:4000,如果页面标题是你前面配置Site里的title.恭喜你更新成功。 部署到github在部署到github之前还需要安装一个依赖 在命令行输入： npm install hexo-deployer-git --save 安装完后再输入： hexo deploy (hexo d) 部署到github上了,这时候你到github打开你的项目，你会看到你在本地仓库的文件都传到了这里。这时，你可以用你的博客地址来查看你的博客了。 主题配置hexo这里有各种各样的主题，总用一款适合你。选好主题之后,进入主题,里面有很详细的配置信息。按照里面的介绍配置即可,在这里我就不再啰嗦了注意：记得在根目录的_config.yml下主题theme那加上你的主题名 theme: 你的主题名 然后更新上传即可]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String,Number和Boolean等基本类型的包装对象]]></title>
    <url>%2F2017%2F11%2F08%2FObject%2F</url>
    <content type="text"><![CDATA[JavaScript的数据类型被分为两大类：引用类型和基本类型。 基本类型：Undefined,Null,Boolean,Number,String,Symbol(ES6新标准出现的数据类型，表示独一无二的值)。 引用类型：Object,Array,Date,RegExp等,你想的没错，引用类型就是对象。 我们都知道引用类型(即对象)都有属性和方法的，而基本类型是木有的，对吧。但是你一定见到过和下面相似的代码： var s=&quot;text&quot;; var s2=s.charAt(1); alert(s);//e 例子中的s是String类型，也就是基本类型，但是s却可以调用出charAt()方法来，这是为什么呢？ 主要是因为在基本类型中，有三个比较特殊的存在就是：String Number Boolean，这三个基本类型都有自己对应的包装对象。并且随时等候召唤。包装对象呢，其实就是对象，有相应的属性和方法。下面来个栗子： var s=&quot;text&quot;; var s2=s.charAt(1);//解析器在解析到这句代码的时候就会在后台执行下面的代码 (//()里面的程序是在后台执行的; var s=new String(&quot;text&quot;);//后台用new来创建了一个基本类型相同的对象 var s2=s.charAt(1);//然后通过新创建的对象来调用charAt()方法，并且返回给s2 s=null//调用完成之后就把这个对象给销毁了 )//实际上这个操作是在一瞬间就完成的，实际上我们没有改变字符串本身的值 alert(s);//e 由此我们可以知道，引用类型和基本包装对象的区别在于：生存期 引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了一瞬间。 所以我们无法直接给基本类型添加方法： var s=&quot;text&quot;;//创建一个字符串 s.length=4;//给它设置一个 属性值 (//()里面的程序是在后台执行的; var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象 var s.length=4;//通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存 因为这个对象马上要被销毁了 s=null;//对象s又被销毁了； ) var l=s.length;//查询这个属性 alert(l);//undefined alert(s.length)//undefined ( var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象 var s.length=undefined;//因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果 s=null;//对象s又被销毁了； ) 当我们要给基本类型加上属性和方法时，我们要在基本包装对象的原型上添加的： //给字符串添加方法 要写到对应的包装对象的原型下才行 var s=&quot;text&quot;; String.prototype.last= fuction(){ return this.charAt(this.length); }; s.last(); ( var str = new String(&apos;hello&apos;);// 找到基本包装对象，new一个和字符串值相同的对象， str.last(); // 通过这个对象找到了包装对象下的方法并调用 str =null; // 这个对象被销毁 )]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中数据类型以及变量作用域]]></title>
    <url>%2F2017%2F11%2F04%2Fzuoyongyu%2F</url>
    <content type="text"><![CDATA[数据类型（变量类型）javascript中的数据类型有：字符串(String)、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空(Null)、未定义(undefined)。 var x ; //x是undefined类型 var x=123; //x是数字类型 var x=&quot;123&quot;; //x是字符串类型 var x=true/false; //x是布尔类型 var x=[]; //x是数组类型 var x={1,2,3} //x是一个对象类型 但是Null这种数据类型该怎么表示呢？其实Null类型只有一个值：null，但是当我们这样写的时候：var x=null; console.log(typeof(x)); 返回的结果却是object,也就是说x是一个对象类型。（在逻辑上，你可以认为null是一个空的对象指针，所以结果为“object”）。那么，我们该如何判断一个类型呢，很简单，我们只要把变量的值与null进行比较即可： &lt;script&gt; var x=null; if(x===null){ alert(&quot;is null&quot;); } alert(null==undefined);//结果为true alert(null===undefined); //结果却为false &lt;/script&gt; 两个等号的时候undefined实际上是从值null派生来的，所以显示true。但是用到严格等于的时候，null和undefined的数据类型是不一样的，所以返回了false。 变量变量的声明在js中，变量声明分为两种，显示声明和隐式声明 var x=100;//显示声明 x=100;//隐式声明 全局变量和局部变量在函数function中使用var声明（即显示声明）的变量是局部变量，而没有var声明（即隐式声明）的变量是全局变量。当我们使用未经任何声明的变量时js就会报错，但是我使用未经声明的而被赋值的变量时js就不会报错了。相反js会认为我们隐式声明了一个全局变量，所以这一点一定要注意。 变量作用域任何程序语言中变量的作用域都是一个很关键的细节。JS中变量的作用域相对与JAVA、C这类语言显得更自由，一个很大的特征就是JS变量没有块级作用域，函数中的变量在整个函数都中有效，看看下面的代码： &lt;script type=&quot;text/javascript&quot;&gt; function outPut(s){ document.writeln(s);//定义一个输出函数 } var i=0;//全局变量 outPut(i);//调用输出函数结果为0 function text(){ var i=1; outPut(i); //1,因为text函数里面定义了一个局部变量，所以在text函数调用outPut的时候是输出text函数里面的局部变量i的值，也就是1 } text(); outPut(i)//仍然是0，因为这时候调用输出函数是在text函数之外调用的，所以里面的局部变量没有起作用； function aa(){ i=2;//这里使用了前面讲的隐式声明，也就是说这里定义了一个全局变量i，而这个i会把前面定义的 同名的全局变量i给覆盖掉 outPut(i);//2 } aa(); outPut(i)//2 i=2; function bb(){ var i; outPut(i);//undefined i=1; outPut(i);//1 }// 这个函数中i已经被var声明了，只是前面未被赋值而已，后面的i虽然是隐式声明的模样，但是别忘了它前面已经被var声明了， bb(); outPut(i);//2 所以bb()中的i并未被覆盖。 &lt;/script&gt; 从上面就可以证明JS如果用var在函数体中声明变量，那么此变量在且只在该函数体内有效，函数运行结束时，本地变量即可销毁了。 基本类型和引用类型 JS不同于JAVA、C这些语言，在变量申明时并不需要声明变量的存储空间。变量中所存储的数据可以分为两类：基本类型和引用类型。其中数值、布尔值、null和undefined属于基本类型，对象、数组和函数属于引用类型。 基本类型在内存中具有固定的内存大小。例如：数值型在内存中占有八个字节，布尔值只占有一个字节。对于引用型数据，他们可以具有任意长度，因此他们的内存大小是不定的，因此变量中存储的实际上是对此数据的引用，通常是内存地址或者指针，通过它们我们可以找到这个数据。 引用类型和基本类型在使用行为上也有不同之处： &lt;script type=&quot;text/javascript&quot;&gt; //定义一个输出函数 function outPut(s){ document.writeln(s) } var a = 3; var b = a; outPut(b); //3 a = 4; outPut(a); //4 outPut(b); //3 &lt;/script&gt; 对基本类型b进行赋值时，实际上是又开辟了一块内存空间，因此改变变量a的值对变量b没有任何影响。 &lt;script type=&quot;text/javascript&quot;&gt; //定义一个输出函数 function outPut(s){ document.writeln(s) } var a_array = [1,2,3]; var b_array = a_array; outPut(b_array); //1,2,3 a_array[3] = 4; outPut(b_array);//1,2,3,4 &lt;/script&gt; 上面是对引用类型的变量赋值，实际上他们传递的是对内存地址的引用，因此对a_array和b_array的存取，实际上都是操作的同一块内存区域。如果希望重新分配内存空间存储引用型变量，那么我就需要使用克隆方法或者自定义方法来复制引用变量的数据。 关于变量作用域我知道的就这些了，这之中有什么写的不对或不够的地方，可以指正出来，也可以和我讨论，分享个人的观点，共同进步。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js中事件的冒泡和事件的捕获]]></title>
    <url>%2F2017%2F10%2F31%2Fevent%2F</url>
    <content type="text"><![CDATA[首先，我们知道微软提出的是事件冒泡，网景提出的是事件捕获。这两个概念的提出是为了解决页面中事件流(即事件发生顺序)的问题。 &lt;div id=&quot;outer&quot;&gt; &lt;p id=&quot;inner&quot;&gt;点击我！&lt;/p&gt; &lt;/div&gt; 上面的代码中一个div元素当中有一个p子元素，如果两个元素都有一onclick事件处理函数，那么我们怎么才能知道哪一个函数会先被触发呢？ 微软和网景这两个公司提出两种相反的概念解决了这个问题。 事件冒泡事件冒泡可以形象地比喻为一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会最内层的元素开始触发，一直往上传播，直到document对象为止。 所以上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document。 事件捕获事件捕获是和事件冒泡完全相反的概念，也就是说，事件会从最外的document对象开始触发，然后不断往里触发。直到最里面的元素被触发为止。 上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p。 在处理事件冒泡中，IE，DOM2级以及DOM0级分别给出以下的处理方法： var EventUtil={ //通过addEventListener 添加监听事件 addHandler:function(element,type,handler){ //element:元素，type:事件类型“click”,handler:处理函数 if(element.addEventListener){ //Dom2级的处理事件 element.addEventListener(type,handler,false); }else if(element.attachEvent){ // IE处理事件 element.attachEvent(&apos;on&apos;+type,handler); }else{ //Dom0级的处理时事件 element[&apos;on&apos;+type]=handler; } }, //通过removeHandler //删除事件 removeHandler:function(element,type,handler){ if(element.removeHandler){//Dom2级的处理事件 element.removeEventListener(type,handler,false); }else if(element.detachEvent){ // IE处理事件 element.detachEvent(&apos;on&apos;+type,handler); }else{//DOM0级处理事件 element[&apos;on&apos;+type]=null; } } } addEventListener的第三个参数“DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。 addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数： element.addEventListener(event, function, useCapture)第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。 阻止事件的冒泡行为以及阻止冒泡函数( stopPropagation())有时候我们开发网页的时候不希望页面出现事件冒泡，我们可以使用阻止事件冒泡处理函数。这个函数使用如下: stopPropagation:function(evnt){ if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble=ture; } 其中的event.cancelBubble=true是指取消事件冒泡，将事件停止下来，不让事件往上面的元素传递。 冒泡还是 捕获？对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。 IE浏览器兼容IE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数object.setCapture();object.attachEvent(event, function)两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。]]></content>
      <categories>
        <category>javscript学习记录</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
