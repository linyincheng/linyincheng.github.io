<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>成成的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://linyincheng.github.io/"/>
  <updated>2018-04-03T13:04:06.359Z</updated>
  <id>https://linyincheng.github.io/</id>
  
  <author>
    <name>Tianyun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ajax的基本应用</title>
    <link href="https://linyincheng.github.io/2017/12/28/suibi/"/>
    <id>https://linyincheng.github.io/2017/12/28/suibi/</id>
    <published>2017-12-28T09:49:46.698Z</published>
    <updated>2018-04-03T13:04:06.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax是前后台实现数据交互的一门技术，可以在无需加载整个网页的情况下能够更新部分网页的技术，也就是说在后台与服务器之间进行少量的数据交互可以使网页不用更新整体，只是更新更改的那一部分。Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。</p><h2 id="Ajax的使用"><a href="#Ajax的使用" class="headerlink" title="Ajax的使用"></a>Ajax的使用</h2><p>使用Ajax需要下载安装它的运行环境<a href="https://www.apachefriends.org/zh_cn/index.html" target="_blank" rel="external">xampp</a>由于是国外的网站，可能会比较慢。进去之后选择与你电脑相匹配的系统版本下载安装，一直点击下一步即可。安装完成后，找到根目录下有一个xampp.contrl.exe 的应用程序，打开这个程序，开启Apache服务器就可以使用了。<br>第一步创建XmlHttpRequest()对象,调用这个对象的open方法，open()接收三个参数，第一个参数是请求方式, 第二个是请求文本的 URL,第三个是是否异步，true表示异步，false表示同步</p><h3 id="Ajax请求纯文本或Ajax请求PHP文件"><a href="#Ajax请求纯文本或Ajax请求PHP文件" class="headerlink" title="Ajax请求纯文本或Ajax请求PHP文件"></a>Ajax请求纯文本或Ajax请求PHP文件</h3><p>首先在xampp/htdocs的路径下新建一个文件夹（名字任你），进去新建一个.txt的文件，里面随便写点吧<br>js代码如下：</p><pre><code>&lt;script&gt;document.getElementsById(&quot;btn&quot;).addEventlistener(&apos;click&apos;,loadTxt);function loadTxt(){var XHR = new XmlHttpRequest();//创建一个对象XHR.open(&apos;GET&apos;,&apos;slow.txt&apos;,true);//如果请求的是PHP文件，把slow.txt改成对应的PHP文件XHR.onload = funciton(){document.write(this.response);};XHR.send();}&lt;/script&gt;</code></pre><h3 id="Ajax请求Json对象"><a href="#Ajax请求Json对象" class="headerlink" title="Ajax请求Json对象"></a>Ajax请求Json对象</h3><pre><code>function loadUser(){        var xhr = new XMLHttpRequest();        xhr.open(&quot;GET&quot;,&quot;user.json&quot;,true);//用Get请求        xhr.onload = function(){            if (this.status == 200) {                // console.log(this.responseText);                var user = JSON.parse(this.responseText);                // console.log(user.name);                var output = &apos;&apos;;                output +=                     &apos;&lt;ul&gt;&apos;+                        &apos;&lt;li&gt;&apos;+user.id+&apos;&lt;/li&gt;&apos;+                        &apos;&lt;li&gt;&apos;+user.name+&apos;&lt;/li&gt;&apos;+                        &apos;&lt;li&gt;&apos;+user.email+&apos;&lt;/li&gt;&apos;+                    &apos;&lt;/ul&gt;&apos;;                ;                document.getElementById(&apos;user&apos;).innerHTML = output;            }        }        xhr.send();    }        </code></pre><h3 id="Ajax请求网络接口-以github接口为例"><a href="#Ajax请求网络接口-以github接口为例" class="headerlink" title="Ajax请求网络接口(以github接口为例)"></a>Ajax请求网络接口(以github接口为例)</h3><pre><code>function loadUsers(){        var xhr = new XMLHttpRequest();        xhr.open(&quot;GET&quot;,&quot;https://api.github.com/users&quot;,true);//这里的URL改成网络地址        xhr.onload = function(){            var users = JSON.parse(this.responseText);            // console.log(users);            var output = &apos;&apos;;            for(var i in users){                output += `                    &lt;div class=&quot;user&quot;&gt;                        &lt;img src=&quot;${users[i].avatar_url}&quot; width=&quot;70&quot; height=&quot;70&quot; /&gt;                        &lt;ul&gt;                            &lt;li&gt;ID: ${users[i].id}&lt;/li&gt;                            &lt;li&gt;Login: ${users[i].login}&lt;/li&gt;                        &lt;/ul&gt;                    &lt;/div&gt;                `;            }            document.getElementById(&apos;users&apos;).innerHTML = output;        }        xhr.send();}</code></pre><h3 id="Ajax的两种请求方式（get请求和post请求）"><a href="#Ajax的两种请求方式（get请求和post请求）" class="headerlink" title="Ajax的两种请求方式（get请求和post请求）"></a>Ajax的两种请求方式（get请求和post请求）</h3><p>get是最常见的请求，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器，对XHR而言，位于传入open( )方法的URL末尾的查询字符串必须经过正确的编码才行，即查询字符串的每个参数的名称和值都 必须使用encodeURIComponent（）进行编码，然后才能放到URL的末尾，而且所有的名-值对都必须由&amp;号分隔；</p><pre><code>xhr.open(&quot;GET&quot;,&quot;example.php?name1=value1&amp;name2=value2&quot;,true);</code></pre><p>POST请求应该把数据作为请求的主体提交，其请求的主体可以包含非常多的数据，而且格式不限。<br>POST请求必须设置Content-Type值为application/x-form-www-urlencoded；如果不设置Content-Type 头部信息，那么发送给服务器的的数据就不会出现在$_POST超全局变量中。<br>发送请求时POST请求在使用send方法时,需赋予其参数； </p><pre><code>xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);xhr.send(params);</code></pre><h3 id="get请求和post请求两者的区别"><a href="#get请求和post请求两者的区别" class="headerlink" title="get请求和post请求两者的区别"></a>get请求和post请求两者的区别</h3><p>（1）使用Get请求时,参数在URL中显示,而使用Post请求,则不会显示出来；<br>（2）Post传输的数据量大，可以达到2M，而Get方法由于受到URL长度的限制,只能传递大约1024字节.<br>（3）Get请求请求需注意缓存问题,Post请求不需担心这个问题；<br>（4）Post请求必须设置Content-Type值为application/x-form-www-urlencoded；<br>（5）发送请求时,因为Get请求的参数都在url里,所以send函数发送的参数为null,而Post请求在使用send方法时,却需赋予其参数；<br>（6）GET方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全问题。而POST方式相对来说就可以避免这些问题。 </p><p>post请求<br>    function postMethod(){</p><pre><code>var xhr = new createXHR();var userName = document.getElementById(&quot;userName&quot;).value;var age = document.getElementById(&quot;age&quot;).value;var data = &quot;userName=&quot; + encodeURTComponent( userName ) + &quot;&amp;age=&quot; + encodeURTComponent( age );//不用担心缓存问题xhr.open( &quot;post&quot;, &quot;example.php&quot;, true );//必须设置,否则服务器端收不到参数xhr.setRequestHeader( &quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot; );xhr.onreadystatechange = function(){    if( xhr.readyState = 4 &amp;&amp; xhr.status == 200 ){        document.getElementById(&quot;result&quot;).innerHTML = xhr.responseText;    }}//发送请求,要data数据xhr.send( data );</code></pre><p>}</p><p>get请求<br>    function getMethod(){</p><pre><code>var xhr = new createXHR();var userName = document.getElementById(&quot;userName&quot;).value;var age = document.getElementById(&quot;age&quot;).value;//添加参数,以求每次访问不同的url,以避免缓存问题xhr.open( &quot;get&quot;, &quot;example.php?userName=&quot; + encodeURTComponent( userName ) + &quot;&amp;age=&quot; + encodeURTComponent( age ) + &quot;&amp;random=&quot; + Math.random(), true );xhr.onreadystatechange = function(){    if( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ){        document.getElementById(&quot;result&quot;).innerHTML = xhr.responseText;    }}//发送请求,参数为nullxhr.send( null );</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h2&gt;&lt;p&gt;Ajax是前后台实现数据交互的一门技术，可以在无需加载整个网页的情况下能够更新部分网页的技术，也就是说在后台与服务器之间进行
      
    
    </summary>
    
    
      <category term="前端开发" scheme="https://linyincheng.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="javascript" scheme="https://linyincheng.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>this的用法</title>
    <link href="https://linyincheng.github.io/2017/11/18/fifth/"/>
    <id>https://linyincheng.github.io/2017/11/18/fifth/</id>
    <published>2017-11-18T12:42:19.406Z</published>
    <updated>2017-12-28T09:54:43.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-this是啥？"><a href="#1-this是啥？" class="headerlink" title="1. this是啥？"></a>1. this是啥？</h2><p>简言之，this是JavaScript语言中定义的众多关键字之一，它的特殊在于它自动定义于每一个函数域内，但是this倒地指引啥东西却让很多人张二摸不着头脑。这里我们留个小悬念，希望看完这篇文章了你能回答出来this到底指引个甚。</p><h2 id="2-this有什么用呢？"><a href="#2-this有什么用呢？" class="headerlink" title="2. this有什么用呢？"></a>2. this有什么用呢？</h2><p>既然this这么难以理解，那么为个甚还要用它呢？我们来看个例子：</p><pre><code>function identify() {return this.name.toUpperCase();}    function sayHello() {var greeting = &quot;Hello, I&apos;m &quot; + identify.call( this );console.log( greeting );}    var person1= {name: &quot;Kyle&quot;};    var person2= {name: &quot;Reader&quot;};    identify.call( person1); // KYLEidentify.call( person2); // READERsayHello.call( person1); // Hello, I&apos;m KYLEsayHello.call( person2); // Hello, I&apos;m READER</code></pre><p>这段代码很简单，我们定义了两个函数，分别为identify和sayHello。并且在不同的对象环境下执行了它们，达到了复用的效果，而不用为了在不同的对象环境下执行而必须针对不同的对象环境写对应的函数了。简言之，this给函数带来了复用。那边客官又问了，我不用this一样可以实现。如：</p><pre><code>function identify(context) {return context.name.toUpperCase();}                    function sayHello(context) {var greeting = &quot;Hello, I&apos;m &quot; + identify( context);console.log( greeting );}    var person1= {name: &quot;Kyle&quot;};    var person2= {name: &quot;Reader&quot;};    identify( person1); // KYLEidentify( person2); // READER    sayHello( person1); // Hello, I&apos;m KYLE    sayHello( person2); // Hello, I&apos;m READER</code></pre><p>仔细一看，这位兄弟给出的解决方法的确也达到了类似的效果。赞一个！我想说的是，随着代码的增加，函数嵌套、各级调用等变得越来越复杂，那么传递一个对象的引用将变得越来越不明智，它会把你的代码弄得非常乱，甚至你自己都无法理解清楚。而this机制提供了一个更加优雅而灵便的方案，传递一个隐式的对象引用让代码变得更加简洁和复用。好了，知道了this的用处，那么再看看我们对它的误解。</p><h2 id="3-我们对this的误解"><a href="#3-我们对this的误解" class="headerlink" title="3. 我们对this的误解"></a>3. 我们对this的误解</h2><p>我们都学过其他语言，在很多编程语言中都有this机制，我们会惯性地把其他语言里对this的理解带入到JavaScript中来，同时，由于this这个单词的理解导致我们对this产生了误解，我们先澄清一下对它的误解。</p><h3 id="3-1-误解一-this引用function本身"><a href="#3-1-误解一-this引用function本身" class="headerlink" title="3.1.误解一  this引用function本身"></a>3.1.误解一  this引用function本身</h3><p>我们都知道，在函数里引用函数可以达到递归和给函数属性赋值的效果。而这在很多应用场景下显得非常有用。所以，很多人都误以为this就是指引function本身。例如：</p><pre><code>function fn(num){console.log(&quot;fn:&quot;+num);this.count++;}fn.count=0;var i;for(i=0;i&lt;10;i++){if(i&gt;5){fn(i);}} //fn:6//fn:7//fn:8//fn:9console.log(fn.count);//0 </code></pre><h3 id="我们对this的误解二"><a href="#我们对this的误解二" class="headerlink" title="我们对this的误解二"></a>我们对this的误解二</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-this是啥？&quot;&gt;&lt;a href=&quot;#1-this是啥？&quot; class=&quot;headerlink&quot; title=&quot;1. this是啥？&quot;&gt;&lt;/a&gt;1. this是啥？&lt;/h2&gt;&lt;p&gt;简言之，this是JavaScript语言中定义的众多关键字之一，它的特殊在于它
      
    
    </summary>
    
      <category term="javscript学习记录" scheme="https://linyincheng.github.io/categories/javscript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://linyincheng.github.io/tags/JavaScript/"/>
    
      <category term="前端开发" scheme="https://linyincheng.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo和github搭建个人博客</title>
    <link href="https://linyincheng.github.io/2017/11/10/forth/"/>
    <id>https://linyincheng.github.io/2017/11/10/forth/</id>
    <published>2017-11-10T12:23:54.753Z</published>
    <updated>2017-11-12T09:46:06.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="github的注册"><a href="#github的注册" class="headerlink" title="github的注册"></a>github的注册</h3><p>gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。<br>所以要使用github，就请先到<a href="https://github.com/" target="_blank" rel="external">github官网</a>进行注测。具体注册过程和关于git的学习，建议到<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137628548491051ccfaef0ccb470894c858999603fedf000" target="_blank" rel="external">廖雪峰的官方网站</a>,这个网站上面有很详细的git教程，希望仔细阅读。</p><h3 id="node-js下载"><a href="#node-js下载" class="headerlink" title="node.js下载"></a>node.js下载</h3><p>由于hexo是基于Node.js的静态博客框架，所以我们先下载node.js,移步<a href="https://nodejs.org/" target="_blank" rel="external">Node.js官网</a>下载稳定版即可，下载完成后打开安装(按照默认路径安装即可)。<br>然后打开cmd命令行或者git Bash 输入：</p><pre><code>node -v</code></pre><p>如果出现版本号就说明已经安装成功了。<br>关于github和hexo的内容就到这里。下面就开始我们的主题（hexo和github搭建个人博客）吧。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>Node和Git都安装好后,用户存放hexo的配置文件,然后安装Hexo。打开 node.js输入：</p><pre><code>sudo npm install -g hexo 或者(nmp i -g hexo)</code></pre><p>安装完成后，到<a href="https://github.com/" target="_blank" rel="external">github</a>登录你前面注册的账号，然后点击<strong>New repository</strong>新建一个项目，项目名为：<em>yourname.github.io</em>,<strong>注意：一个账号只能建立一个名为yourname.github.io，如果已经有了，就随便建一个 如：blog</strong><br>将项目克隆到本地仓库，打开git Bash上(<em>注意：你想把这个 项目放到哪个磁盘就在哪个磁盘打开git Bash</em>，但是最好不要放在C盘).</p><pre><code>git clone 你项目上的SSh</code></pre><p>克隆完成后，打开文件夹，打开git Bash或者cmd(注意是当前路径就行)输入：</p><pre><code>hexo init</code></pre><p>安装hexo所需要的依赖。<br>好啦，到此为止呢，所有的安装工作都完成了！接下来就是生成博客页面了。</p><h3 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h3><pre><code>hexo generate (hexo g)</code></pre><p>这时你的博客页面已经生成，然后再输入：</p><pre><code>hexo sever (hexo s)</code></pre><p>启动本地服务,进行博客页面的预览,完成这一步后,进入<a href="http://localhost:4000/" target="_blank" rel="external">localhost:4000</a>查看hexo页面是否出现,一般来说使用了yourname.github.io创建的项目名都可以看到页面,而其他的看不到页面的,因为你们的环境还没配置好<strong>(不要着急，接着往下看！)</strong></p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>首先，你要找到项目根目录下的_config.yml文件,打开文件进行配置。</p><h5 id="Site-基本信息部分"><a href="#Site-基本信息部分" class="headerlink" title="Site(基本信息部分)"></a>Site(基本信息部分)</h5><pre><code># Sitetitle: //博客名subtitle: //可填可不填description: //你博客的描述author: //作者language: zh-Hanstimezone: Asia/Shanghai</code></pre><p><strong>特别提醒：冒号后面有个空格，这个空格必不可少！！下面的内容也一样！！！！</strong></p><h5 id="URL-博客地址"><a href="#URL-博客地址" class="headerlink" title="URL(博客地址)"></a>URL(博客地址)</h5><p>如果你是使用<em>yourname.github.io</em>为项目名的话，那你就如下配置就行。<strong>root</strong>后面不能为空</p><pre><code>url: https://yourname.github.io/root: /    </code></pre><p>要是你是用其他的项目名的话，比如blog,请按照下面配置：</p><pre><code>url: https://yourname.github.io/blogroot: /blog</code></pre><p>完成这里之后,看到文件的最后。</p><h5 id="Deployment-部署信息"><a href="#Deployment-部署信息" class="headerlink" title="Deployment(部署信息)"></a>Deployment(部署信息)</h5><pre><code>deploy:   type: git   repository: 你项目的SSH   branch: master(如果博客地址是“https://yourname.github.io/blog”,分支名就是gh-pages)</code></pre><p>全局配置结束。这时候你需要更新你的本地仓库。在命令行输入：</p><pre><code>hexo generate(hexo g)hexo sever  (hexo s)    </code></pre><p>点击<a href="http://localhost:4000/" target="_blank" rel="external">localhost:4000</a>,如果页面标题是你前面配置Site里的title.恭喜你更新成功。</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>在部署到github之前还需要安装一个依赖 在命令行输入：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>安装完后再输入：</p><pre><code>hexo deploy (hexo d)</code></pre><p>部署到github上了,这时候你到github打开你的项目，你会看到你在本地仓库的文件都传到了这里。这时，你可以用你的博客地址来查看你的博客了。</p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="external">hexo</a>这里有各种各样的主题，总用一款适合你。<br>选好主题之后,进入主题,里面有很详细的配置信息。按照里面的介绍配置即可,在这里我就不再啰嗦了<br><em>注意：记得在根目录的_config.yml下主题theme那加上你的主题名</em></p><pre><code>theme: 你的主题名</code></pre><p>然后更新上传即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;github的注册&quot;&gt;&lt;a href=&quot;#github的注册&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="随笔" scheme="https://linyincheng.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hexo" scheme="https://linyincheng.github.io/tags/hexo/"/>
    
      <category term="github" scheme="https://linyincheng.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>String,Number和Boolean等基本类型的包装对象</title>
    <link href="https://linyincheng.github.io/2017/11/08/three/"/>
    <id>https://linyincheng.github.io/2017/11/08/three/</id>
    <published>2017-11-08T12:40:29.000Z</published>
    <updated>2017-11-11T09:55:16.277Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript的数据类型被分为两大类：引用类型和基本类型。</p><p>基本类型：Undefined,Null,Boolean,Number,String</p><p>引用类型：Object,Array,Date,RegExp等,你想的没错，引用类型就是对象。</p><p>我们都知道引用类型(即对象)都有属性和方法的，而基本类型是木有的，对吧。但是你一定见到过和下面相似的代码：</p><pre><code>var s=&quot;text&quot;;var s2=s.charAt(1);alert(s);//e    </code></pre><p>例子中的s是String类型，也就是基本类型，但是s却可以调用出charAt()方法来，这是为什么呢？</p><p>主要是因为在基本类型中，有三个比较特殊的存在就是：String Number Boolean，这三个基本类型都有自己对应的包装对象。并且随时等候召唤。包装对象呢，其实就是对象，有相应的属性和方法。下面来个栗子：</p><pre><code>var s=&quot;text&quot;;var s2=s.charAt(1);//解析器在解析到这句代码的时候就会在后台执行下面的代码(//()里面的程序是在后台执行的;    var s=new String(&quot;text&quot;);//后台用new来创建了一个基本类型相同的对象    var s2=s.charAt(1);//然后通过新创建的对象来调用charAt()方法，并且返回给s2    s=null//调用完成之后就把这个对象给销毁了)//实际上这个操作是在一瞬间就完成的，实际上我们没有改变字符串本身的值alert(s);//e    </code></pre><p>由此我们可以知道，引用类型和基本包装对象的区别在于：<font face="微软雅黑" size="16" color="#ff0000">生存期</font></p><p>引用类型所创建的对象，在执行的期间一直在内存中，而基本包装对象只是存在了一瞬间。</p><p>所以我们无法直接给基本类型添加方法：</p><pre><code>var s=&quot;text&quot;;//创建一个字符串s.length=4;//给它设置一个 属性值(//()里面的程序是在后台执行的;    var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象    var s.length=4;//通过这个对象调用包装对象下的方法 但结果并没有被任何东西保存 因为这个对象马上要被销毁了    s=null;//对象s又被销毁了；)var l=s.length;//查询这个属性alert(l);//undefinedalert(s.length)//undefined(    var s= new String(&quot;text&quot;); //后台用new来创建了一个基本类型相同的对象    var s.length=undefined;//因为包装对象下面没有number这个属性，所以又会重新添加，因为没有值，所以值是未定 ;然后弹出结果    s=null;//对象s又被销毁了；)    </code></pre><p>当我们要给基本类型加上属性和方法时，我们要在基本包装对象的原型上添加的：</p><pre><code>//给字符串添加方法  要写到对应的包装对象的原型下才行var s=&quot;text&quot;;String.prototype.last= fuction(){ return this.charAt(this.length);}; s.last();(   var str = new String(&apos;hello&apos;);// 找到基本包装对象，new一个和字符串值相同的对象，   str.last();  // 通过这个对象找到了包装对象下的方法并调用    str =null; //  这个对象被销毁)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript的数据类型被分为两大类：引用类型和基本类型。&lt;/p&gt;
&lt;p&gt;基本类型：Undefined,Null,Boolean,Number,String&lt;/p&gt;
&lt;p&gt;引用类型：Object,Array,Date,RegExp等,你想的没错，引用类型就是对象。&lt;/
      
    
    </summary>
    
      <category term="javscript学习记录" scheme="https://linyincheng.github.io/categories/javscript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://linyincheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js中数据类型以及变量作用域</title>
    <link href="https://linyincheng.github.io/2017/11/04/second/"/>
    <id>https://linyincheng.github.io/2017/11/04/second/</id>
    <published>2017-11-04T04:50:14.136Z</published>
    <updated>2017-11-04T13:23:16.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型（变量类型）"><a href="#数据类型（变量类型）" class="headerlink" title="数据类型（变量类型）"></a>数据类型（变量类型）</h2><p>javascript中的数据类型有：字符串(String)、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空(Null)、未定义(undefined)。</p><pre><code>var x ;           //x是undefined类型var x=123;     //x是数字类型var x=&quot;123&quot;;  //x是字符串类型var x=true/false;  //x是布尔类型var x=[];          //x是数组类型var x={1,2,3}   //x是一个对象类型</code></pre><p>但是Null这种数据类型该怎么表示呢？其实Null类型只有一个值：null，但是当我们这样写的时候：var  x=null;  console.log(typeof(x)); 返回的结果却是object,也就是说x是一个对象类型。（在逻辑上，你可以认为null是一个空的对象指针，所以结果为“object”）。<br>那么，我们该如何判断一个类型呢，很简单，我们只要把变量的值与null进行比较即可：</p><pre><code>&lt;script&gt;var x=null;if(x===null){alert(&quot;is null&quot;);  }alert(null==undefined);//结果为truealert(null===undefined); //结果却为false&lt;/script&gt;</code></pre><p>两个等号的时候undefined实际上是从值null派生来的，所以显示true。但是用到严格等于的时候，null和undefined的数据类型是不一样的，所以返回了false。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h4><p>在js中，变量声明分为两种，显示声明和隐式声明</p><pre><code>var x=100;//显示声明x=100;//隐式声明</code></pre><h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>在函数function中使用var声明（即显示声明）的变量是局部变量，而没有var声明（即隐式声明）的变量是全局变量。<br>当我们使用未经任何声明的变量时js就会报错，但是我使用未经声明的而被赋值的变量时js就不会报错了。相反js会认为我们隐式声明了一个全局变量，所以这一点一定要注意。</p><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>任何程序语言中变量的作用域都是一个很关键的细节。JS中变量的作用域相对与JAVA、C这类语言显得更自由，一个很大的特征就是JS变量没有块级作用域，函数中的变量在整个函数都中有效，看看下面的代码：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;function outPut(s){document.writeln(s);//定义一个输出函数}var i=0;//全局变量outPut(i);//调用输出函数结果为0function text(){var i=1;outPut(i);//1,因为text函数里面定义了一个局部变量，所以在text函数调用outPut的时候是输出text函数里面的局部变量i的值，也就是1}text();outPut(i)//仍然是0，因为这时候调用输出函数是在text函数之外调用的，所以里面的局部变量没有起作用；function aa(){i=2;//这里使用了前面讲的隐式声明，也就是说这里定义了一个全局变量i，而这个i会把前面定义的 同名的全局变量i给覆盖掉outPut(i);//2}aa();outPut(i)//2 i=2;function bb(){    var i;    outPut(i);//undefined    i=1;    outPut(i);//1}//  这个函数中i已经被var声明了，只是前面未被赋值而已，后面的i虽然是隐式声明的模样，但是别忘了它前面已经被var声明了，bb();outPut(i);//2  所以bb()中的i并未被覆盖。&lt;/script&gt;</code></pre><p>从上面就可以证明JS如果用var在函数体中声明变量，那么此变量在且只在该函数体内有效，函数运行结束时，本地变量即可销毁了。</p><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><p>　JS不同于JAVA、C这些语言，在变量申明时并不需要声明变量的存储空间。变量中所存储的数据可以分为两类：基本类型和引用类型。其中数值、布尔值、null和undefined属于基本类型，对象、数组和函数属于引用类型。<br>　　基本类型在内存中具有固定的内存大小。例如：数值型在内存中占有八个字节，布尔值只占有一个字节。对于引用型数据，他们可以具有任意长度，因此他们的内存大小是不定的，因此变量中存储的实际上是对此数据的引用，通常是内存地址或者指针，通过它们我们可以找到这个数据。<br>　　引用类型和基本类型在使用行为上也有不同之处：</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;//定义一个输出函数 function outPut(s){ document.writeln(s) } var a = 3; var b = a; outPut(b); //3 a = 4; outPut(a); //4 outPut(b); //3 &lt;/script&gt;</code></pre><p>对基本类型b进行赋值时，实际上是又开辟了一块内存空间，因此改变变量a的值对变量b没有任何影响。</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;//定义一个输出函数 function outPut(s){ document.writeln(s) } var a_array = [1,2,3]; var b_array = a_array; outPut(b_array); //1,2,3 a_array[3] = 4; outPut(b_array);//1,2,3,4 &lt;/script&gt;</code></pre><p>　上面是对引用类型的变量赋值，实际上他们传递的是对内存地址的引用，因此对a_array和b_array的存取，实际上都是操作的同一块内存区域。如果希望重新分配内存空间存储引用型变量，那么我就需要使用克隆方法或者自定义方法来复制引用变量的数据。</p><p>关于变量作用域我知道的就这些了，这之中有什么写的不对或不够的地方，可以指正出来，也可以和我讨论，分享个人的观点，共同进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型（变量类型）&quot;&gt;&lt;a href=&quot;#数据类型（变量类型）&quot; class=&quot;headerlink&quot; title=&quot;数据类型（变量类型）&quot;&gt;&lt;/a&gt;数据类型（变量类型）&lt;/h2&gt;&lt;p&gt;javascript中的数据类型有：字符串(String)、数字(Numbe
      
    
    </summary>
    
      <category term="javscript学习记录" scheme="https://linyincheng.github.io/categories/javscript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://linyincheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Js中事件的冒泡和事件的捕获</title>
    <link href="https://linyincheng.github.io/2017/10/31/first/"/>
    <id>https://linyincheng.github.io/2017/10/31/first/</id>
    <published>2017-10-31T08:42:12.439Z</published>
    <updated>2017-11-04T09:36:14.741Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们知道微软提出的是事件冒泡，网景提出的是事件捕获。这两个概念的提出是为了解决页面中事件流(即事件发生顺序)的问题。</p><pre><code>&lt;div id=&quot;outer&quot;&gt;    &lt;p id=&quot;inner&quot;&gt;点击我！&lt;/p&gt;&lt;/div&gt;</code></pre><p>上面的代码中一个div元素当中有一个p子元素，如果两个元素都有一onclick事件处理函数，那么我们怎么才能知道哪一个函数会先被触发呢？</p><p>微软和网景这两个公司提出两种相反的概念解决了这个问题。</p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡可以形象地比喻为一颗石头投入水中，泡泡会一直从水底冒出水面，也就是说，事件会最内层的元素开始触发，一直往上传播，直到document对象为止。</p><p>所以上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -&gt; div -&gt; body -&gt; html -&gt; document。</p><h2 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2><p>事件捕获是和事件冒泡完全相反的概念，也就是说，事件会从最外的document对象开始触发，然后不断往里触发。直到最里面的元素被触发为止。</p><p>上面的例子在事件捕获的概念下发生click事件的顺序应该是document -&gt; html -&gt; body -&gt; div -&gt; p。</p><p>在处理事件冒泡中，IE，DOM2级以及DOM0级分别给出以下的处理方法：</p><pre><code>var EventUtil={//通过addEventListener 添加监听事件addHandler:function(element,type,handler){//element:元素，type:事件类型“click”,handler:处理函数    if(element.addEventListener){ //Dom2级的处理事件        element.addEventListener(type,handler,false);    }else if(element.attachEvent){ // IE处理事件        element.attachEvent(&apos;on&apos;+type,handler);    }else{      //Dom0级的处理时事件        element[&apos;on&apos;+type]=handler;    }},//通过removeHandler//删除事件removeHandler:function(element,type,handler){if(element.removeHandler){//Dom2级的处理事件    element.removeEventListener(type,handler,false);}else if(element.detachEvent){ // IE处理事件    element.detachEvent(&apos;on&apos;+type,handler);}else{//DOM0级处理事件     element[&apos;on&apos;+type]=null;}},}</code></pre><hr><h2 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h2><p>“DOM2级事件”中规定的事件流同时支持了事件捕获阶段和事件冒泡阶段，而作为开发者，我们可以选择事件处理函数在哪一个阶段被调用。</p><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：</p><p>element.addEventListener(event, function, useCapture)第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p><h2 id="阻止事件的冒泡行为以及阻止冒泡函数-stopPropagation"><a href="#阻止事件的冒泡行为以及阻止冒泡函数-stopPropagation" class="headerlink" title="阻止事件的冒泡行为以及阻止冒泡函数( stopPropagation())"></a>阻止事件的冒泡行为以及阻止冒泡函数( stopPropagation())</h2><p>有时候我们开发网页的时候不希望页面出现事件冒泡，我们可以使用阻止事件冒泡处理函数。这个函数使用如下:</p><pre><code>stopPropagation:function(evnt){    if(event.stopPropagation){        event.stopPropagation();    }else{        event.cancelBubble=ture;    }</code></pre><p>其中的event.cancelBubble=true是指取消事件冒泡，将事件停止下来，不让事件往上面的元素传递。</p><h2 id="冒泡还是-捕获？"><a href="#冒泡还是-捕获？" class="headerlink" title="冒泡还是 捕获？"></a>冒泡还是 捕获？</h2><p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p><h2 id="IE浏览器兼容"><a href="#IE浏览器兼容" class="headerlink" title="IE浏览器兼容"></a>IE浏览器兼容</h2><p>IE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。<br>要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数<br>object.setCapture();<br>object.attachEvent(event, function)<br>两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，我们知道微软提出的是事件冒泡，网景提出的是事件捕获。这两个概念的提出是为了解决页面中事件流(即事件发生顺序)的问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;outer&amp;quot;&amp;gt;
    &amp;lt;p id=&amp;quot;inner&amp;qu
      
    
    </summary>
    
      <category term="javscript学习记录" scheme="https://linyincheng.github.io/categories/javscript%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://linyincheng.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://linyincheng.github.io/2017/10/31/hello-world/"/>
    <id>https://linyincheng.github.io/2017/10/31/hello-world/</id>
    <published>2017-10-31T07:52:33.811Z</published>
    <updated>2017-11-03T11:20:22.734Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://linyincheng.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
